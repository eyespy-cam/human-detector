import KeycloakAdminClient from '@keycloak/keycloak-admin-client';
import { Readable } from 'stream';
import {
  GenericContainer,
  StartedTestContainer,
  StoppedTestContainer,
  Wait,
} from 'testcontainers';
import { Labels, ExecResult } from 'testcontainers/dist/docker/types';
import { TokenSet, Issuer, Client as OpenIDClient } from 'openid-client';
import { v4 } from 'uuid';

const KEYCLOAK_PORT = 8080;

export class KeycloakContainer extends GenericContainer {
  private admin = 'admin';
  private adminPassword = 'admin';

  constructor(image = 'quay.io/keycloak/keycloak:19.0.2') {
    super(image);
  }

  public withAdmin(admin: string) {
    this.admin = admin;
  }

  public withAdminPassword(adminPassword: string) {
    this.adminPassword = adminPassword;
  }

  public async start(): Promise<StartedKeycloakContainer> {
    this.withExposedPorts(KEYCLOAK_PORT)
      .withWaitStrategy(Wait.forLogMessage(/Added user/))
      .withEnv('KC_HTTP_ENABLED', 'true')
      .withEnv('KC_HOSTNAME_STRICT', 'false')
      .withEnv('KEYCLOAK_ADMIN', this.admin)
      .withEnv('KEYCLOAK_ADMIN_PASSWORD', this.adminPassword)
      .withCmd(['start', '--optimized']);

    const container = await super.start();
    const kcAdminClient = new KeycloakAdminClient({
      baseUrl: `http://localhost:${container.getMappedPort(KEYCLOAK_PORT)}`,
    });
    await kcAdminClient.auth({
      username: this.admin,
      password: this.adminPassword,
      grantType: 'password',
      clientId: 'admin-cli',
    });

    return new StartedKeycloakContainer(container, kcAdminClient);
  }
}

export class StartedKeycloakContainer implements StartedTestContainer {
  private container: StartedTestContainer;
  private adminClient: KeycloakAdminClient;
  private testLoginClients = new Map<string, OpenIDClient>();

  constructor(
    container: StartedTestContainer,
    adminClient: KeycloakAdminClient,
  ) {
    this.container = container;
    this.adminClient = adminClient;
  }

  public getPort(): number {
    return this.container.getMappedPort(KEYCLOAK_PORT);
  }

  /**
   * Enables the [Resource Owner Password Credentials Grant](https://www.rfc-editor.org/rfc/rfc6749#section-4.3)
   * flow in a realm by creating a direct grant client.
   */
  public async addPasswordLoginToRealm(realm: string): Promise<void> {
    if (this.testLoginClients.get(realm) === undefined) {
      const clientId = 'test-login';
      const clientSecret = v4();
      await this.adminClient.clients.create({
        realm,
        clientId: clientId,
        clientAuthenticatorType: 'client-secret',
        directAccessGrantsEnabled: true,
        secret: clientSecret,
        enabled: true,
      });
      const issuer = new Issuer({
        issuer: `http://localhost:${this.getPort()}/realms/${realm}`,
        token_endpoint: `http://localhost:${this.getPort()}/realms/${realm}/protocol/openid-connect/token`,
      });
      const client = new issuer.Client({
        client_id: clientId,
        client_secret: clientSecret,
      });
      this.testLoginClients.set(realm, client);
    }
  }

  /**
   * Creates a user in the given realm.
   * @param realm realm to create the user in
   * @param username
   * @param password
   * @returns ID of the new user
   */
  public async createUser(
    realm: string,
    username: string,
    password: string,
  ): Promise<string> {
    const { id } = await this.adminClient.users.create({
      realm,
      username,
      enabled: true,
    });
    await this.adminClient.users.resetPassword({
      realm,
      id,
      credential: {
        value: password,
      },
    });
    return id;
  }

  /**
   * Get a set of tokens for a user using their name and password as login info.
   * @returns a token set
   */
  public async loginAsUser(
    realm: string,
    username: string,
    password: string,
  ): Promise<TokenSet> {
    // Ensures that a login client exists for this realm
    await this.addPasswordLoginToRealm(realm);
    const client = this.testLoginClients.get(realm);
    return client.grant({
      grant_type: 'password',
      username,
      password,
    });
  }

  /**
   * Create a dummy user with an autogenerated set of credentials.
   */
  public async createDummyUser(
    realm: string,
  ): Promise<{ id: string; username: string; password: string }> {
    const username = v4();
    const password = 'security-is-my-passion';
    const id = await this.createUser(realm, username, password);
    return { id, username, password };
  }

  /**
   * Create a dummy user in the given realm and log in as them, returning their credentials.
   * Useful for auth testing.
   */
  public async createDummyUserAndLogIn(
    realm: string,
  ): Promise<{ id: string; tokenSet: TokenSet }> {
    const { id, username, password } = await this.createDummyUser(realm);
    const tokenSet = await this.loginAsUser(realm, username, password);
    return { id, tokenSet };
  }

  // AbstractStartedContainer (https://github.com/testcontainers/testcontainers-node/blob/a1ba007381db58d5374f46bcd7810687e559495b/src/modules/abstract-started-container.ts)
  // isn't exported from 'testcontainers', so we have to write the boilerplate ourselves. :(

  public async stop(options?: unknown): Promise<StoppedTestContainer> {
    return this.container.stop(options);
  }
  public async restart(options?: unknown): Promise<void> {
    this.container.restart(options);
  }
  public getHost(): string {
    return this.container.getHost();
  }
  public getMappedPort(port: number): number {
    return this.container.getMappedPort(port);
  }
  public getName(): string {
    return this.container.getName();
  }
  public getLabels(): Labels {
    return this.container.getLabels();
  }
  public getId(): string {
    return this.container.getId();
  }
  public getNetworkNames(): string[] {
    return this.container.getNetworkNames();
  }
  public getNetworkId(networkName: string): string {
    return this.container.getNetworkId(networkName);
  }
  public getIpAddress(networkName: string): string {
    return this.container.getIpAddress(networkName);
  }
  public async exec(command: string[]): Promise<ExecResult> {
    return this.container.exec(command);
  }
  public async logs(): Promise<Readable> {
    return this.container.logs();
  }
}
